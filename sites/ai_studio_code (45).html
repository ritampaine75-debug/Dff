<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>AI Air Canvas Pro</title>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/vision_bundle.js" crossorigin="anonymous"></script>
    <style>
        body, html { margin: 0; padding: 0; width: 100%; height: 100%; overflow: hidden; background: #000; font-family: 'Segoe UI', sans-serif; }
        
        #container { position: relative; width: 100vw; height: 100vh; }
        video, #drawCanvas, #uiCanvas { 
            position: absolute; top: 0; left: 0; width: 100%; height: 100%; 
            object-fit: cover; transform: scaleX(-1); 
        }

        #drawCanvas { z-index: 2; }
        #uiCanvas { z-index: 3; pointer-events: none; } /* Used for the finger cursor */
        video { z-index: 1; opacity: 0.3; }

        /* UI Styling */
        #overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0,0,0,0.9); z-index: 100;
            display: flex; flex-direction: column; justify-content: center; align-items: center;
            color: white; text-align: center;
        }

        .status-bar {
            position: fixed; top: 20px; left: 50%; transform: translateX(-50%);
            z-index: 50; background: rgba(0,0,0,0.6); padding: 10px 25px;
            border-radius: 30px; color: white; font-weight: bold; border: 1px solid #444;
        }

        .controls {
            position: fixed; bottom: 30px; left: 50%; transform: translateX(-50%);
            z-index: 50; display: flex; gap: 15px;
        }

        button {
            padding: 15px 30px; font-size: 16px; border-radius: 50px;
            border: none; background: #007bff; color: white; font-weight: bold;
            box-shadow: 0 4px 15px rgba(0,0,0,0.3);
        }

        #clearBtn { background: #ff4757; }
        .eraser-active { color: #ff4757; border-color: #ff4757; }
    </style>
</head>
<body>

    <div id="overlay">
        <h2 id="statusText">Loading AI...</h2>
        <button id="startBtn" style="display:none;">Start Drawing</button>
    </div>

    <div class="status-bar" id="modeIndicator">Mode: Waiting...</div>

    <div id="container">
        <video id="webcam" autoplay playsinline></video>
        <canvas id="drawCanvas"></canvas>
        <canvas id="uiCanvas"></canvas>
        
        <div class="controls">
            <button id="clearBtn">Clear All</button>
        </div>
    </div>

<script type="module">
    import { HandLandmarker, FilesetResolver } from "https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3";

    const video = document.getElementById("webcam");
    const drawCanvas = document.getElementById("drawCanvas");
    const uiCanvas = document.getElementById("uiCanvas");
    const drawCtx = drawCanvas.getContext("2d");
    const uiCtx = uiCanvas.getContext("2d");
    const modeIndicator = document.getElementById("modeIndicator");
    
    let handLandmarker = undefined;
    let lastVideoTime = -1;
    let lastPoint = null;
    let isEraser = false;

    // Settings
    const DRAW_COLOR = "#00D2FF";
    const PEN_WIDTH = 8;
    const ERASER_WIDTH = 60;

    async function init() {
        const vision = await FilesetResolver.forVisionTasks("https://cdn.jsdelivr.net/npm/@mediapipe/tasks-vision@0.10.3/wasm");
        handLandmarker = await HandLandmarker.createFromOptions(vision, {
            baseOptions: {
                modelAssetPath: `https://storage.googleapis.com/mediapipe-tasks/hand_landmarker/hand_landmarker.task`,
                delegate: "GPU"
            },
            runningMode: "VIDEO",
            numHands: 1
        });
        document.getElementById("statusText").innerText = "AI Ready!";
        document.getElementById("startBtn").style.display = "block";
    }

    document.getElementById("startBtn").addEventListener("click", () => {
        navigator.mediaDevices.getUserMedia({ video: { facingMode: "user" } }).then(stream => {
            video.srcObject = stream;
            document.getElementById("overlay").style.display = "none";
            resize();
            video.addEventListener("loadeddata", predict);
        });
    });

    function resize() {
        drawCanvas.width = uiCanvas.width = window.innerWidth;
        drawCanvas.height = uiCanvas.height = window.innerHeight;
    }
    window.addEventListener('resize', resize);

    async function predict() {
        if (video.currentTime !== lastVideoTime) {
            lastVideoTime = video.currentTime;
            const results = handLandmarker.detectForVideo(video, performance.now());
            
            uiCtx.clearRect(0, 0, uiCanvas.width, uiCanvas.height);

            if (results.landmarks && results.landmarks.length > 0) {
                const hand = results.landmarks[0];
                const indexTip = hand[8];
                const thumbTip = hand[4];

                // Convert to pixels
                const x = indexTip.x * drawCanvas.width;
                const y = indexTip.y * drawCanvas.height;

                // 1. CALCULATE DISTANCE FOR GESTURE (Pinch detection)
                const distance = Math.sqrt(
                    Math.pow(indexTip.x - thumbTip.x, 2) + 
                    Math.pow(indexTip.y - thumbTip.y, 2)
                );

                // If distance between thumb and index is very small (like your photo)
                isEraser = distance < 0.05; 

                // 2. UPDATE UI
                updateUI(x, y, isEraser);

                // 3. DRAW OR ERASE
                performAction(x, y, isEraser);
            } else {
                lastPoint = null;
                modeIndicator.innerText = "Mode: No Hand Detected";
            }
        }
        requestAnimationFrame(predict);
    }

    function updateUI(x, y, erasing) {
        // Draw visual cursor
        uiCtx.beginPath();
        uiCtx.arc(x, y, erasing ? 20 : 10, 0, Math.PI * 2);
        uiCtx.strokeStyle = erasing ? "red" : "white";
        uiCtx.lineWidth = 3;
        uiCtx.stroke();

        modeIndicator.innerText = erasing ? "MODE: ERASER (PINCHING)" : "MODE: PAINTING";
        modeIndicator.style.color = erasing ? "#ff4757" : "#00D2FF";
    }

    function performAction(x, y, erasing) {
        drawCtx.lineCap = "round";
        drawCtx.lineJoin = "round";

        if (erasing) {
            // Eraser Mode logic
            drawCtx.globalCompositeOperation = 'destination-out';
            drawCtx.lineWidth = ERASER_WIDTH;
        } else {
            // Paint Mode logic
            drawCtx.globalCompositeOperation = 'source-over';
            drawCtx.strokeStyle = DRAW_COLOR;
            drawCtx.lineWidth = PEN_WIDTH;
        }

        if (lastPoint) {
            drawCtx.beginPath();
            drawCtx.moveTo(lastPoint.x, lastPoint.y);
            drawCtx.lineTo(x, y);
            drawCtx.stroke();
        }
        lastPoint = { x, y };
    }

    document.getElementById("clearBtn").onclick = () => {
        drawCtx.clearRect(0, 0, drawCanvas.width, drawCanvas.height);
    };

    init();
</script>
</body>
</html>